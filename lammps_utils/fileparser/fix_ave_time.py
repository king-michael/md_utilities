#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Python script to handle LAMMPS fix ave/time files

Author : Michael King <michael.king@uni-konstanz.de>
"""

import numpy as np
from warnings import warn

__author__ = "Michael King"


def read_ave_time(fname, dim=1, dtype=float):
    # type: (str, int, type) -> (np.ndarray, np.ndarray)
    r"""
    Function to parse a output file generated by fix ave/time from LAMMPS.
    
    Parameters
    ----------
    fname : str
        filename
    dim : int, optional
        number of dimentions per bin in the file
    dtype : type, optional
        dtype for the data
    
    Returns
    -------
    timesteps : array of dtype int
        Array with the timesteps in the file
    data : array
        Array with the read datapoints in the format ``(n_timesteps, n_maxvalues)`` for ``dim = 1``
        or ``(n_frames, max_nvalues, dim)`` for ``dim != 1``
        with ``n_frames`` as number of frames in the file, 
        ``max_nvalues`` maximum number of bins per frame,
        ``dim`` number of values per bin

    Examples
    --------
    >>> timesteps, data = read_ave_time("tmp.out", dtype=int)

    """

    # initialize
    n_frames = 0
    constant = True
    init = True
    
    # read in file
    if fname[-3:] == '.gz':
        import gzip
        lines = gzip.open(fname, 'r').readlines()
    else:
        lines = open(fname, 'r').readlines()
    iter_lines = iter(lines)

    # first parse of the file to read in the data
    for line in iter_lines:
        line = line.strip()
        
        # skip comments
        if line[0] == '#':
            continue

        line_split = line.split()
        
        timestep, nvalues = int(line_split[0]), int(line_split[1])
        
        # initialize 
        if init:
            max_nvalues = nvalues
            init = False
        
        # check if if nvalues is constants and get the maximum
        if nvalues != max_nvalues:
            constant = False
            if max_nvalues < nvalues:
                max_nvalues = nvalues

        # count time step
        n_frames += 1
        
        # parse the values per timestep
        for ival in range(nvalues):
            # just skip them
            # TODO: get the length of them and set dim if dim == 'auto'
            iter_lines.next()
    
    # Warings
    if not constant:
        warn("Not a constant number of values per timestep")

    # init arrays
    if dim == 1:
        data = np.empty([n_frames, max_nvalues], dtype=dtype)
        row = np.empty(max_nvalues, dtype=dtype)
    else:
        data = np.empty([n_frames, max_nvalues, dim], dtype=dtype)
        warn("dim not tested yet")
    
    timesteps = np.empty([n_frames], dtype=int)

    # counter for timestep
    frame = 0

    # reset iteration
    iter_lines = iter(lines)

    # read in data
    for line in iter_lines:
        line = line.strip()
        
        # skip comments
        if line[0] == '#':
            continue

        line_split = line.split()
        
        timestep, nvalues = int(line_split[0]), int(line_split[1])

        # add time step
        timesteps[frame] = int(timestep)

        # parse the values per timestep
        for ival in range(nvalues):
            line = iter_lines.next().strip()
            line_split = line.split()
            
            # store the data
            if dim == 1:
                row[ival] = dtype(line_split[1])
            else:
                for idim in range(dim):
                    # TODO: Do row-wise handling
                    data[frame, ival, idim] = dtype(line_split[1+idim])

        # store the data
        if dim == 1:            
            data[frame, :nvalues] = row[:nvalues]
            
        # count time step
        frame += 1

    return timesteps, data
